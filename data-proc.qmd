---
title: "Data Processing"
---

## Overview


```{r import gt package}
#| message: false
library(tidyverse)
library(tidylog)
```


```{r read in county dataframe}
#| echo: false
df_counties <- read_rds("intermediate/df_countries_prepped.rds")
```


## Feature Inspection


### `year`
We know from the county dashboard that the data should be from 2011 to 2021. This feature is really categorical, not numeric. There is also a distinct order, so it will be converted into an ordinal factor.

```{r distinct years}
df_counties |> 
  distinct(year) |> pull()
```
There are 10 distinct `year` values, which is expected. Given that the data are correct, we can now convert to a factor.

```{r convert year to factor}
df_counties <- df_counties |> 
  mutate(
    year = fct_inseq(factor(year, ordered = TRUE))
  )

head(df_counties$year)
```
Now `year` is a factor ordered sequentially.

### `geography`
The `geography` feature contains the state and county names. There are 39 counties in Washington, so we expect that there will be 40 distinct values in this feature. This feature is also categorical in nature, but nominal rather than ordinal.

```{r distinct geographies}
df_counties |> 
  distinct(geography) |> pull()
```
It looks like the data are correct. There are 40 distinct values, as expected.

```{r geography as factor}
df_counties <- df_counties |> 
  mutate(
    geography = factor(geography)
  )
levels(df_counties$geography)
```
The levels have been recorded alphabetically, which makes sense for the most part. Since "Washington State" isn't a county, it can be repositioned at the front, to separate it from the counties.

```{r}
df_counties$geography <- fct_relevel(df_counties$geography, "Washington State", after=0)
levels(df_counties$geography)
```
Now the factor is set up properly.

### `selection_filter`
Next, look at the selection filter distinct values.

```{r distinct selection_filter}
df_counties |> 
  distinct(selection_filter) |> pull()
```
These are all reasonable. The only one that we are interested in is the "Age"
filter.

```{r filter on Age}
df_counties <- df_counties |>
  filter(selection_filter == "Age")
```

### `selection_value`

The selection values should now only pertain to "Age".

```{r distinct selection_value}
df_counties |> 
  distinct(selection_value) |> pull()
```
These values look correct. Nothing more needs to be done with this variable.

### `max_percent_total_population`
This feature pertains to what percentage of the population a given filter 
applies to for the given `geography`. It's a percentage, so all values should be 
between 0 and 100.

```{r}
summary(df_counties$max_percent_total_population)
```
There are no missing values and all values are positive and range between 0 and 100, so this data is valid.

### `max_sub_population`
This feature pertains to the number of people that fall into the given
`selection_filter`/`selection_value` combination for the given `geography`. All 
values should be positive and no larger than the total population of the state 
(at most).

```{r}
summary(df_counties$max_sub_population)
```
This is the case. There are no missing values.

### `max_total_population`
Without a codebook, it is not clear what this feature represents. Furthermore, 
most of the observations are missing data for this variable. Given that this 
field won't be required for our purposes, it will be removed from the dataset.

```{r summary max_total_population}
summary(df_counties$max_total_population)
```

```{r}
df_counties <- df_counties |> 
  select(-max_total_population)
```



## Dataframe pivot and new feature creation 
Now, we need to pivot all of the age data into a single observation so that we
can perform different dependency ratio calculations for each year/geography
combination. We will need to first filter out all of the non "Age" selection
filters, then drop the variables that we don't need for our calculations so
that we get a single observation for each year/geography combination.


```{r pivot wider}
df_counties <- df_counties |> 
  select(-c(max_percent_total_population, selection_filter)) |> 
  pivot_wider(names_from=selection_value, values_from=max_sub_population, names_prefix="age_") |> 
  clean_names()

df_counties <- df_counties |> 
  mutate(
    total_dep_ratio = round((age_65 + age_1_14 + age_1)/(age_45_64 + age_25_44 + age_15_24)*100,2),
    child_dep_ratio = round((age_1_14 + age_1)/(age_45_64 + age_25_44 + age_15_24)*100,2),
    aged_dep_ratio = round((age_65)/(age_45_64 + age_25_44 + age_15_24)*100,2)
  )
```



```{r save data as RDS}
#| echo: false
# This step is required for quarto websites where each document executes in its own environment. The
# dataframe will have to be saved to RDS format at the end of each step of the analysis so that its state
# is preserved for the next step to load it and continue.
write_rds(df_counties, file="intermediate/df_countries_proced.rds")
```

